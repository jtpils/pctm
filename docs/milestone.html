<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <style>
        body {
            padding: 100px;
            margin: auto;
            text-align: left;
            font-weight: 400;
            font-family: 'Open Sans', sans-serif;
            font-size: 12pt;
            color: #000000;
        }

        h1, h2, h3, h4 {
            font-family: 'Source Sans Pro', sans-serif;
        }

        /*
        div.padded {
          padding-top: 0px;
          padding-right: 100px;
          padding-bottom: 0.25in;
          padding-left: 100px;
        }
        */
    </style>
    <title>Milestone Status Report</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="style.css" media="screen"/>
</head>
<body>
<br/>
<h1 align="middle">Milestone Status Report: Point Cloud to Mesh</h1>
<h2 align="middle">Evan Chang, Rene Lee, William Jow</h2>
<br>
<br>

<div class="padded">
    <h2 align="left">Summary of Accomplishments</h2>
    <p>
        So far, we have written code to parse the input .ply files and to perform the preliminary steps of the
        ball-pivoting algorithm. Specifically, of the four major operations (spatial hashing, seed selection,
        ball-pivoting and join/glue) outlined in the reference paper, we have made progress toward completing the first
        two.
    </p>
    <p>
        Our first task was to create a spatial grid of the vertices that were parsed from the .ply files. This was
        done through the same way we did in project 4. We created a map that maps a hashcode position to a list of
        points. This gave us quicker access to neighboring points. For seed selection, we have also figured out a way to
        find the center of a ball that touches all 3 vertices of a potential seed triangle.
    </p>
    <p>
        We are currently working on a method for estimating vertex normals, which we realized are required by the
        algorithm and are not given in the input files, as well as finishing up code for the ball-pivoting and join/glue
        portions of the algorithm.
    </p>

    <h2 align="left">Preliminary Results</h2>
    <p>
        To parse .ply code, our team used the Rply library to easily go through the .ply file line by line and parse
        through
        different sections of the input file. To do this, I used a helper function to parse through each vertex line and
        stored
        the position information in a global list of vertices. Following the schematics of CS184 project 2's code, I
        then added
        the list of vertices to a node as a polymesh and pushed the node to the back of nodes to render at the end of
        the main function.
        To render each point, I changed some code in meshEdit to render points rather than render meshes. Below are some
        snippets of
        code used to parse and render ply files, as well as some rendered images of a scanned bunny model from various
        input angles.
    </p>
    <table style="width=100%">
        <tr>
            <td>
                <img src="images/parse_ply_code.png" align="middle" width="400px"/>
                <figcaption align="middle">code used to parse a ply file</figcaption>
            </td>
            <td>
                <img src="images/parse_vertex_code.png" align="middle" width="400px"/>
                <figcaption align="middle">code used to parse each vertex line</figcaption>
            </td>
        </tr>
        <tr>
            <td>
                <img src="images/render_ply_code.png" align="middle" width="400px"/>
                <figcaption align="middle">code used to render each point</figcaption>
            </td>
        </tr>
        <br>
    </table>
    <table style="width=100%">
        <tr>
            <td>
                <img src="images/bun000_ply.png" align="middle" width="400px"/>
                <figcaption align="middle">bun000.ply</figcaption>
            </td>
            <td>
                <img src="images/bun180_ply.png" align="middle" width="400px"/>
                <figcaption align="middle">bun180.ply</figcaption>
            </td>
        </tr>
        <tr>
            <td>
                <img src="images/bun270_ply.png" align="middle" width="400px"/>
                <figcaption align="middle">bun270.ply</figcaption>
            </td>
        </tr>
        <br>
    </table>

    <h2 align="left">Reflection of Progress</h2>
    <p>
        After having the .ply files converted and almost being done with find seed triangle, we just need to continue to
        follow the pseudocode from the research paper on the ball-pivoting algorithm and do testing. The code that we
        need to work on after finding the seed triangle is figuring out the glue and join helper functions that go with
        the ball-pivoting algorithm. With those three ball-pivoting helper functions created, hopefully we can easily
        implement the ball-pivoting algorithm and test our code. We believe that we are on track to figure out the
        ball-pivoting algorithm by the time the final deliverables are due.
    </p>

    <p>
        Video Explanation link: https://drive.google.com/open?id=1qWXYMsk_iGdAqTHUru9skpUl9y8UUay7
    </p>

</div>
</body>
</html>
